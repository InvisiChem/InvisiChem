For now, you should probably just ignore this entire portal to my non-existent repositories, the massive amount of awesome C, C++, BASIC and my own language
code that is not there. It will happen, I have just been dealing with real life. Anyways, I am the InvisiChem. I am from the United States in Arizona, but I'm
not like these morons. I actually think, hold to moral ideals, care about those I interact with and many I don't interact with and just want to make a better
corner of this world before I leave it to my daughter to continue.

Programming is definitely my longest hobby and the one I absolutely enjoy the most. I use a much more old school approach, considering I learned before GUI's
were invented. The closest we had initially was the text based graphics from the extended ASCII sets to create the various objects one font character at a time.
It forced us to really think about the applications we were about to design though. Even without a GUI/TUI interface, you had to be able to format text quickly,
make the system move the cursor and provide prompts in an intuitive way so the user could not only be efficient, but be comfortable using your software. They
should never have to <TAB> through fields to reach certain input fields or other annoyances like that. 

Interface design was much more challenging then, but I believe the actual writing was much easier then. Simply put, all language were top down languages and a
few provided support for subroutines and/or functions. Even fewer supported library/header files and I can only think of maybe 5 that supported inline assembly
calls from within the application context. So, approximately 32 word language, base libraries are all you have access to, no internet exists for the public yet,
system this will deploy on is probably one of the cool white or green monochome monitors anyways and you have decided to create a rogue type text based role
playing game which institutes some primitive text based graphics(small world map in the upper right corner, line art to provide decorative boxes and such around
the input/output boxes at the bottom, on screen there is some line art objects which come on screen if they encounter things like monsters, cliffs, dungeons,
treasures, lost villager, etc.)

This is what truly takes time. In those days, remember this is high school for me, I actually sat down and designed the basic flow of the never ending, unless
you get killed, type of game. Then I started getting into the detail stuff, like encounter probability mechanics based on the location in the large made up map,
battle mechanics, character creation and attribute designations. Luckily, I had been playing Dungeons and Dragons for several years, so it was natural to use
random number generation and create a random system which functioned precisely with the DND 2nd Edition rules, had my little enhancements to balance out how bad
random can really be and the majority of the game is taking shape. Once I completed designing how objects, monsters, weapons, treasures, thieves, gifters, relics,
magic spells, etc. could be represented in tables, then I was ready to begin the pseudocode algorithms.

Thats about as far as I will take this. Before I entered even a single word of code, i.e. int main(void) { return 0 }, I had already defined every necessary piece
of the game and any future games that used those pieces. File structures and formatting, read world definition files which could be easily created in any text
editor, down to the detail that I wanted the program to accept each character as it was typed, echoing the character back into the console while processing inline
and not forcing a pause of action to type in a command like walk left. I could discern that by taking in the input and knew at wal that it was walking, at walk l I
could already update the maps, roll the dice, consult the weather manager, etc. We literally took it down to where Each function did one thing and did it well. If
any function was at all complicated, it just meant that I was not at the function levels yet. I needed to refine my algorithm into more algorithms until Each one
performed a single action, represented a single attribute, etc. This made coding so easy. 

The main function was only around 400 lines of C code once complete. I had over 700 functions though. But the groups had a constructor driver to create an object,
say a simple pond. Well, this consisted of functions to describe the pond, one of base type water. It needed at least 15 others of type duck, edible fish, inedible
fish, water depth, moss, temperature, etc. This was just to describe an object. We call those classes these days, but we didn't have them then. haha.

So, to the point, I tend to program on my own, without collaboration unless it is a project I need the help with, time sensitive, or just want to enjoy absorbing
another style for once but mostly, I do this for fun and like my solitude.
